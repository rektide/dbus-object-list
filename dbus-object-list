"use strict"

let materialize= require( "./materialize")

function DbusObjectList( baseName, target, opts){
	opts= opts|| {}
	let
	  origInterface= opts.interface,
	  origType= opts.type
	if( baseName instanceof Function){
		opts.type= baseName
		baseName= [ baseName.name.slice( 0, 1).toLowerCase(), baseName.name.slice( 1)].join( "")
	}
	if( opts.type&& opts.type.interface){
		opts.interface= opts.type.interface
	}
	let
	  first= baseName.slice( 0, 1),
	  cap= first.toUpperCase(),
	  rest= baseName.slice( 1),
	  baseInterface= opts.baseInterface
	if( baseInterface){
		opts.interface= [baseInterface, ".", cap, rest].join( "")
	}
	let
	  newObj= [ "New", cap, rest].join( ""),
	  removedObj= [ "Removed", cap, rest].join( ""),
	  capPlural= [ cap, rest, baseName.plural? baseName.plural: "s"].join( ""),
	  materializer= opts.interface? materialize( opts): null,
	  emit= opts.emit,
	  value= materializer? {}: [],
	  done
	opts.interface= origInterface
	opts.type= origType
	// bound below: materializer, value, emit, capPlural... oh and opts.
	if(materializer){
		done = Promise.resolve( target).then( target=>{
			return new Promise(( resolve, reject)=> {
				target.on( newObj, newPath=>{ // subscribe to new
					materializer( newPath, opts).then( materialized=> {
						value[ newPath]= materialized
						if( emit){
							emit( baseName, materialized, newPath)
				} }) })
				target.on( removedObj, removePath=>{ // subscribe to remove
					delete value[ removePath]
					if( emit){
						emit( baseName, null, removeObj)
				} })
				target[ capPlural](( err, initial)=>{ // retrieve initial value
					if( err) return reject( err)
					let all= initial.map( materializer)
					Promise.all( all).then(function( all){
						for(var i in initial){
							let path= initial[ i]
							value[ path]= all[ i]
						}
						resolve( value)
					}, reject)
	}) }) }) }else{
		done = Promise.resolve( target).then( target=>{
			return new Promise(( resolve, reject)=> {
				target[ capPlural](( err, initial)=>{ // retrieve initial value
					if( err) return reject( err)
					value.push.apply( value, initial) // append
					resolve( value)
				})
				target.on( newObj, newPath=>{ // subscribe to new
					value.push( newPath)
					if( emit){
						emit( baseName, newPath, newPath)
					}
				})
				target.on( removedObj, removePath=>{ // subscribe to remove
					let i= value.indexOf( removePath)
					if( i === -1){
						return
					}
					value.splice( i, 1)
					if( emit){
						emit( baseName, null, removePath)
					}
				})
			})
		  })
	}
	return {value, done}
}



module.exports= DbusObjectList
